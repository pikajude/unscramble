<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Distributive</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Distributive.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributive-0.2.2: Haskell 98 Distributive functors -- Dual to Traversable</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Maintainer</th><td>Edward Kmett &lt;ekmett@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Infered</td></tr></table><p class="caption">Data.Distributive</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> g =&gt; <a href="#t:Distributive">Distributive</a> g  <span class="keyword">where</span><ul class="subs"><li><a href="#v:distribute">distribute</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f =&gt; f (g a) -&gt; g (f a)</li><li><a href="#v:collect">collect</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f =&gt; (a -&gt; g b) -&gt; f a -&gt; g (f b)</li><li><a href="#v:distributeM">distributeM</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m (g a) -&gt; g (m a)</li><li><a href="#v:collectM">collectM</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; g b) -&gt; m a -&gt; g (m b)</li></ul></li><li class="src short"><a href="#v:cotraverse">cotraverse</a> :: (<a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (f a -&gt; b) -&gt; f (g a) -&gt; g b</li><li class="src short"><a href="#v:comapM">comapM</a> :: (<a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (m a -&gt; b) -&gt; m (g a) -&gt; g b</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> g =&gt; <a name="t:Distributive" class="def">Distributive</a> g  <span class="keyword">where</span></p><div class="doc"><p>This is the categorical dual of <code>Traversable</code>. However, there appears
 to be little benefit to allow the distribution via an arbitrary comonad
 so we restrict ourselves to <code><a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a></code>.
</p><p>Minimal complete definition: <code><a href="Data-Distributive.html#v:distribute">distribute</a></code> or <code><a href="Data-Distributive.html#v:collect">collect</a></code>
</p><p>To be distributable a container will need to have a way to consistently
 zip a potentially infinite number of copies of itself. This effectively
 means that the holes in all values of that type, must have the same 
 cardinality, fixed sized vectors, infinite streams, functions, etc.
 and no extra information to try to merge together.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:distribute" class="def">distribute</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f =&gt; f (g a) -&gt; g (f a)</p><div class="doc"><p>The dual of <code><a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Traversable.html#v:sequence">sequence</a></code>
</p><pre> distribute = collect id
</pre></div><p class="src"><a name="v:collect" class="def">collect</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f =&gt; (a -&gt; g b) -&gt; f a -&gt; g (f b)</p><div class="doc"><pre> collect = distribute . fmap f
</pre></div><p class="src"><a name="v:distributeM" class="def">distributeM</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m (g a) -&gt; g (m a)</p><div class="doc"><pre> distributeM = fmap unwrapMonad . distribute . WrapMonad
</pre></div><p class="src"><a name="v:collectM" class="def">collectM</a> :: <a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; g b) -&gt; m a -&gt; g (m b)</p><div class="doc"><pre> collectM = distributeM . liftM f
</pre></div></div><div class="subs instances"><p id="control.i:Distributive" class="caption collapser" onclick="toggleSection('i:Distributive')">Instances</p><div id="section.i:Distributive" class="show"><table><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> <a href="/usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/transformers-0.3.0.0/html/Data-Functor-Identity.html#t:Identity">Identity</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> ((-&gt;) e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> g =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (<a href="/usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/transformers-0.3.0.0/html/Control-Monad-Trans-Identity.html#t:IdentityT">IdentityT</a> g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Distributive.html#t:Distributive">Distributive</a> g =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (<a href="/usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/transformers-0.3.0.0/html/Control-Monad-Trans-Reader.html#t:ReaderT">ReaderT</a> e g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Distributive.html#t:Distributive">Distributive</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (<a href="/usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/transformers-0.3.0.0/html/Data-Functor-Compose.html#t:Compose">Compose</a> f g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Distributive.html#t:Distributive">Distributive</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; <a href="Data-Distributive.html#t:Distributive">Distributive</a> (<a href="/usr/local/Cellar/haskell-platform/2012.4.0.0/share/doc/transformers-0.3.0.0/html/Data-Functor-Product.html#t:Product">Product</a> f g)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:cotraverse" class="def">cotraverse</a> :: (<a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Functor">Functor</a> f, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (f a -&gt; b) -&gt; f (g a) -&gt; g b</p></div><div class="top"><p class="src"><a name="v:comapM" class="def">comapM</a> :: (<a href="/usr/local/Cellar/ghc/7.4.2/share/doc/ghc/html/libraries/base-4.5.1.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="Data-Distributive.html#t:Distributive">Distributive</a> g) =&gt; (m a -&gt; b) -&gt; m (g a) -&gt; g b</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>